■6.1 メソッド宣言
- この本では、オブジェクトはメソッドを持つ単なる値あるいは変数で、メソッドは特定の方に関連付けられた関数。
- メソッドは普通の関数宣言の変形で宣言され、そこでは関数名の前に追加のパラメータが書かれる。そのパラメータが当のパラメータの型へ関数を結びつける。
  type Point struct { X, Y float64 }
  
  func Distance(p, q Point) float64 { // 昔ながらの関数
      return math.Hypot(q.X-p.X, q.Y-p.Y)
  }
  
  func (p Point) Distance(q Point) float64 // Point型のメソッド
      return math.Hypot(q.X-p.X, q.Y-p.Y)
  }
  p := Point{1, 2}
  q := Point{4, 6}
  fmt.Println(p.Distance(q)) // "5", メソッド呼び出し。
- 上記メソッドの p はレシーバと呼ばれる。Goではレシーバに対し、this や self などの特別な名前は使わない。
- レシーバ名は頻繁に使われるので短くメソッド間で一貫するのが望ましく、Pointに対する p など、型名の頭文字などよく利用される。
- メソッドとフィールドは同じ名前空間に存在するため、メソッド名とフィールド名が同一のものを定義すると曖昧となりコンパイルエラーとなる。
- スライス型などもtype宣言で名前を付けることができ、メソッドを関連付けることができる。この点は他言語と異なる点。★
  type Path []Point
  func (path Path) Distance() float64 { // pathに沿って進んだ距離を返す。
      sum := 0.0
      for i := range path {
          if i > 0 {
              sum += path[i-1].Distance(path[i])
          }
      }
      return sum
  }
- マップや関数も名前付き型にすればメソッド定義できる。基底型がポインタかインタフェースでない限り同一パッケージ内の名前付き方にはメソッド宣言できる。★
- 関数でなくメソッドを使う利点の一つは型の名前があるのでメソッド名を短くできる点。パッケージ外からの呼び出しでこの利点は増大する。

■6.2 ポインタレシーバを持つメソッド
- *Pointなどのポインタ型にもメソッドを結び付けられる。以下のメソッドの名前は(*Point).ScaleBy(()をつけないと*(Point.ScaleBy)と解釈されるので注意)。
  func (p *Point) ScaleBy(factor float64) {
      p.X *= factor
      p.Y *= factor
  }
- 慣習として、Pointのどれかのメソッドがポインタレシーバを持つ場合、Pointの すべて のメソッドはポインタレシーバを持つべきとなる。★
- 名前付き型 (Point) とその型へのポインタ (*Point) は、レシーバ宣言に書くことができる。曖昧さを避けるため、それ自身がポインタの名前付き型はメソッド宣言できない。★
  type P *int
  func (P) f() { ... } // コンパイルエラー: 不正なレシーバ型
- ポインタのレシーバの利用方法は以下。最後の呼び出しもOKで、コンパイラが暗黙で&pを行う。Pointのメソッドを*Pointで呼び出すことも可能。★
  r := &Point{1, 2}
  r.ScaleBy(2)

  p := Point{1, 2}
  pptr := &p
  pptr.ScaleBy(2)

  (&p).ScaleBy(2)

  p.ScaleBy(2) // コンパイラが暗黙で&pを利用してくれる。変数 (アドレス化可能) の場合のみ暗黙の変換をしてくれる。
- アドレス化可能でない Point レシーバに対して *Point を呼び出すことはできない、
  Point{1, 2}.ScaleBy(2) // コンパイルエラー: Pointリテラルのアドレスは得られない。
- 以下が成立すればメソッド呼び出しが可能。
 - レシーバ引数がレシーバパラメータと同じ型。
 - レシーバ引数が型 T の変数で、レシーバパラメータが型 *T である。(コンパイラが暗黙でその変数のアドレスを得る。)
 - レシーバ引数の型が *T で、レシーバパラメータは型 T である。(コンパイラは暗黙的にレシーバの指す値を参照する。)
- 名前付き型 T のすべてのメソッドが T (*Tでなく)のレシーバを持つならその型のインスタンスをコピーすることは安全。メソッド呼び出しではコピーが行われるから。
- どれかのメソッドがポインタレシーバをもっていると、その名前付き型のインスタンスコピーは避けるべき。内部の不変式を破る可能性があるから。★
　コピーしたインスタンスがコピー元のインスタンス操作で変更されうるので。

■6.2.1 nil は正当なレシーバ値
- 特にマップやスライスのように nil がその型のゼロ値を意味する場合などあるため、nil をレシーバとして利用することは許されている。
  func (list *IntList) Sum() int {
      if list == nil {
          return 0
      }
      ...
- レシーバ値として nil を許すメソッドを持つ型を定義する場合、ドキュメンテーションコメントで明示すべき。★

■6.3 構造体埋め込みによる型の合成


