■7 インタフェース
- Goのインタフェースは暗黙的に満足される。具象型が満足するすべてのインタフェース宣言する必要はなく、必要なメソッドを持つだけで十分。

■7.1 契約としてのインタフェース
- インタフェースは、内部構造を公開していない振る舞いを一般化あるいは抽象化したもの。
- インタフェース型の値がある場合、その値が何かは示されず、その値で何ができるか、その値でメソッドがどう振る舞うかが示される。
- io.Writer インタフェースは Fprintf とその呼び出し元の間の契約を定義する。
  package fmt
  func Fprintf(w io.Writer, format string, args ...interface{}) (int, error)

  package io
  type Writer interface {
          // Write は p から len(p) バイトの基底のデータストリームへ書き込みます。
          // p から書き込まれたバイト数 (0 <= n <= len(p)) と、書き込みを早く終わらせた原因となったエラーを返します。
          // Write は、n < len(p) であるような n を返す場合には nil ではない error を返さなければなりません。
          // Write は、たとえ一時的であってもスライスのデータを変更してはいけません。
          // 実装は、p を持ち続けてはいけません。
          Write(p []byte) (n int, err error)
  }
- *os.File や *bytes.Buffer のような具象型は、適切な Write メソッドの振る舞いを呼び出し元に提供することが求められる。
- fmt.Fprintf は io.Writer の内部表現は意識しない。io.Writer の契約で保証される振る舞いのみに依存するため、io.Writerの実体は代替可能。★

■7.2 インタフェース型
- インタフェース型は具象型がそのインタフェースのインスタンスとして見なされるために持たなければならないメソッドの集まりの定義。
- 既存の型の組み合わせとして新たなインタフェース型を宣言できる。構造体埋め込みに似た構文でインタフェースを**埋め込み**することができる。
  package io
  
  type ReadWriteCloser interface { // 埋め込みによるインタフェース組み合わせ方法。
      Reader
      Writer
      Closer
  }
  type ReaderWriter interface {  // 埋め込みではないインタフェース組み合わせ方法。
      Read(p []byte) (n int, err error)
      Write(p []byte) (n int, err error)
  }

■7.3 インタフェースを満足する
- インタフェースに対する代入可能性の規則は単純。その型がインタフェースを満足していれば代入可能。
- インタフェースは具象型とその型が保持する値を包み隠す。具象型が他のメソッドを持っていてもそのインタフェース型が公開しているメソッドしか呼べない。
  os.Stdout.Write([]byte("hello")) // OK: *os.File は Write メソッドあり
  os.Stdout.Close()                // OK: *os.File は Close メソッドあり

  var w io.Writer
  w = os.Stdout
  w.Write([]byte("hello")) // OK: io.Writer は Write メソッドあり
  w.Close()                // コンパイルエラー: io.Writer は Close メソッドなし
- 空インタフェース型 (interface{}) は全くメソッドを持たない。それを満足する方に何も要求していないので、全ての値を空インタフェースに代入できる。
  var any interface{}
  any = true
  any = 12.34
  any = "hello"
  ...
- 宣言の方法により型がインタフェースを満足することを強制することも可能。
  var w io.Writer = new(bytes.Buffer)    // *bytes.Buffer は io.Writer を満足しなければならない
  var _ io.Writer = (*bytes.Buffer)(nil) // *bytes.Buffer は io.Writer を満足しなければならない
- 一つのクラスが満足するインタフェースの集まりをクラスで明示的に記述する言語と異なり、Go は具象型の宣言を修正することなく、必要な場合に新たな抽象化つまり、
　興味ある部分の新たなグループ化を行うことができる。★

■7.4 flag.Value によるフラグの解析
- flag.Duration 関数は time.Duration 型のフラグ変数を生成し、String メソッドで表示されたものと同じ表記を含む、さまざまな使いやすい形式でユーザが期間を指定できる。


