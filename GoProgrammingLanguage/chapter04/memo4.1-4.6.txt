■4.1 配列
- 配列は特定の型の0個以上の固定長列。Goで配列が使われることはまれ。
- [...] が長さの場所に書かれた場合、初期化子の配列リテラルの要素数になる。
- 次のようにインデックスと値の組のリストを指定することも可能。
  type Currency int
  const (
      USD Currency = iota
      EUR
      GBP
      RMB
  )
  symbobl := [...]string{USD: "$", EUR: "C", GBP: "L", RMB: "\"}
- 上記記法でインデックスを省略してもよく、省略時はゼロ値が要素に入る。
- Goで配列を関数に渡すとコピーが渡される。関数内での配列操作が呼び出し元の配列に影響しない。大きい配列だと非効率になるので注意。
- 配列を関数に渡す場合、ポインタ私もできる。その場合、関数内での配列操作が呼び出し元の配列に影響する。
  func foo(ptr *[32]byte) {

■4.2 スライス
- 大きさがない配列のようなもの。可変長列。
- cap(s)を超えてスライスを作成するとパニックになるが、len(s)を超えてのスライスの作成はそのスライスを拡張する。
- スライスは配列の要素へのポインタを含んでいるので関数へのスライスを渡すことでその関数は規定配列の要素を変更することができる。
  func reverse(s []int) {
  ...
  reverse(a[2:]) // スライスaの要素に対する操作がreverseで行われた場合、呼び出し元のaにも影響する。
- 配列と異なりスライスは比較可能ではない。ただしバイトスライス([]byte)は最適化されたbytes.Equal関数がある。
- 唯一正当なスライスの比較はnilとの比較のみ。空のスライスかどうか見分ける場合はlen(s) == 0を使う。

4.2.1 append関数
- append関数はスライスに要素を追加する。
  runes = append(runes, r)
- 配列の拡張ごとに配列の大きさを倍にするのは実行効率の点でよい。appendは以下のappendIntより洗練された拡張方法を使っているかもしれません。
  func appendInt(x []int, y int) []int (
      var z []int
      zlen:= len(x) + 1
      if zlen <= cap(x)
          z = [:zlen] // capに追加の余地がある。
      } else {
          zcap := zlen
          if zcap< 2*len(x) {
              zcap= 2 * len(x)
          }
          z = make([]int, zlen, zcap)
          copy(z, x) // 組み込み関数。
      }
      z[len(z)] = y
      return z
  }
- スライスを使うとstackが簡単に実装できる。要素削除のremove実装例は以下。
  func remove(slice []int, i int) slice[] {
      copy(slice[i:], slice[i+ 1:])
      return slice[:len(slice) - 1]
  }

■4.3 マップ



