https://golang.org/dl/
上記からインストーラをダウンロードしてGoを使えるようにする。

■2.1 名前
- 名前の最初の文字が大文字か小文字かでその名前がパッケージの境界を越えて見えるか否かが決まる。大文字から始まる場合は公開を意味する。★
- Goはキャメルケース(アッパーキャメル 単語のはじめを大文字にする)で書くのが慣習らしい。
- HTMLなどの頭文字の集合は常に大文字か常に小文字で書くのが慣習らしい。HTML, htmlはOKだがHtmlはダメ。

■2.2 宣言
- ソースコードの.goファイルはどのパッケージに属すかを宣言するpackage宣言から始まり、import宣言が続き、型、変数、関数のパッケージレベルの宣言が任意の順で宣言される。
- 大域的な場所に宣言された小文字から始まるエンティティは、パッケージ内で可視となる。

■2.3 変数
- 変数宣言の = の右辺が省略されるとその変数の型のゼロ値となる。
- 数値は0、boolはfalse、文字列は ""、インタフェースと参照型はnilがゼロ値。配列や構造体の合成型のゼロ価はすべての要素やフィールドでゼロ値をとる。
- ゼロ値の利用により、Goには未初期化の変数はない。
- 複数の変数を宣言し、リストで初期化できる。
  var i, j, k int
  var b, f, s = true, 2.3, "four"
- パッケージレベルの変数はmainが始まる前に初期化される。ローカル変数は関数の実行中の宣言に出会ったときに初期化される。

■2.3.1 省略変数宣言
- 関数内でローカル変数を宣言して初期化するために利用。大域的なスコープでは利用できない。
- 複数の変数を同一の省略変数宣言で宣言して初期化できるが、可読性が向上する場合にのみ利用すべき。forループの初期化部分のような短くて自然なグループ化などでのみ利用が推奨。
- 複数の変数を省略変数宣言で宣言する場合、すべてが新しい変数宣言になるわけではない。err などよく利用する変数の場合、二度目の同一スコープで省略宣言で利用するときは代入のように働く。
- 省略変数宣言で宣言する変数は少なくとも1つは新しい変数宣言でなければならない。新しい変数宣言がないとコンパイルエラーになる。★

■2.3.2 ポインタ
- 変数に&をつけると変数のポインタに、ポインタに*をつけるとポインタの変数の値にアクセスできる。
  x := 1
  p := &x          // pは*int型で、xを指している
  fmt.Println(*p)  // "1"
  *p = 2           // x = 2と同じ
  fmt.Println(x)   // "2"
- ポインタのゼロ値はnil。
- 関数がローカル変数のアドレスを返すのは安全。★
- ポインタ引数を関数に渡すことで関数が間接的に渡された変数を更新することができる。
- ポインタは変数のエイリアス。スライス、マップ、チャネルなど他の参照型の値をコピーしたときにもエイリアスが発生する。

■2.3.3 new関数
- newは構文上の利便性であるだけで基本的な概念ではない。あまり使わない。
- newは事前宣言された関数で、予約語ではないので、関数内で別の概念にnewという名前を使える。

■2.3.4 変数の生存期間
- 変数は到達不可能になるまで生存する。ローカル変数のポインタが返される関数が定義された場合、関数を抜けても返されるローカル変数は到達可能であるため生存し続ける。
　このような変数は関数からエスケープしているという。パフォーマンスを最適化する際は、エスケープを意識すると良い。
- ガベージコレクションは正しいプログラムを作成するために役立つが、メモリについて考える重荷を取り除くものではない。変数の生存期間を意識することは重要。★

■2.4 代入
■2.4.1 ダブル代入


