■3.1 整数
- int, uintは32か64bitだが、そのサイズがどちらであるか想定した実相をしてはいけない。コンパイラで変わりうるから。
- uintptr は幅の規定がない。ポインタの値のすべてのビットを保持するのに十分な幅は持つ。
- 演算子は結びつきの優先度が5段階ある。同じ優先度の演算子が並ぶ場合、左に結び付く。わかりやすさのため () でくくること推奨。
- 余剰演算子 % は整数のみ利用可。負の余剰の振る舞いは言語で異なり、Goでは剰余の符号は被除数 (%の左の数値) の符号と同じになる。
- オーバーフロー時は方に収まらない上位ビットが破棄される。
- 符号付数値の右へのビットシフトは空いたビットに符号ビットをコピーして埋める。整数をビットパターンとして扱う場合、符号なし算術を使うことが重要。
- sliceのlenは明らかに正の整数だが、int型。for文の初期化節でlen使った際にuintで返されると、iがuintになり、思わぬ動作になりうる。
- 上記などを理由に符号なし数値は単なる負ではない数量に対しては普通は使われない。
- 符号なし数値はビットセットの実装、バイナリファイル形式の解析、ハッシュや暗号化のビット演算子、普通と異なる算術演算子が必要な場合用いられる。
- T(x)により大きい整数から小さい整数型に変換したり、整数を浮動小数点型に(逆も)変換する場合、値が変更されたり精度を失いうる。★
- Printfのverbで%の後に[1]とすると、第一オペランドが利用される。
  fmt.Printf("%d, %[1]x", x) // %d, %[1]x ともに第一オペランド x が利用される。

■3.2 浮動小数点数
- 浮動小数点数の限界値は mathパッケージ に定義されている。
- float32は6桁の、float64は15桁の10進の精度を有す。float32は誤差が大きいのでfloat64を使うのが好ましい。★
- mathパッケージには正の無限大、負の無限大、NaN(not a number:0/0などの数学的に疑わしい演算の結果) の定義などがある。
- math,NaN() 同士の比較演算結果は != を除いて常にfalseになるので注意。
  nan := math.NaN()
  if nan == nan { // false
  if nan < nan {  // false
  if nan > nan {  // false

■3.3 複素数
- complex64, complex128はそれぞれ実部、虚部がfloat32とfloat64の複素数。
- x := 1 + 2i のように、iをつけると虚数。var x complex128 := complex(1, 2) と同じ。
- math.complexパッケージで複素数の算術を行える。

■3.4 ブーリアン
- && は || より優先順位が高い。&&はブーリアン乗算、||はブーリアン加算と覚えるとよい。

■3.5 文字列
- len関数は文字列中のバイト数を返す。
- ASCIIでないコードポイントのUTF-8は2バイト以上必要(1文字が2バイト以上) となるので注意。
- 文字列の比較演算は辞書順。
- 文字列は不変なので、文字列のデータを直接変更する構文は許されない。
  s[0] = 'L' // コンパイルエラー: s[0] には代入できない。
- 


